//
//  File.swift
//  
//
//  Created by Александр Никитин on 06.07.2021.
//

import Foundation

/// A single airport. For info about the file format refer to [the official apt.dat documentation](https://developer.x-plane.com/article/airport-data-apt-dat-file-format-specification/)
public struct Airport: Codable {
    // Autogenerated memberwise initializer so that it can be made public
    public init(rowCode: Int, elevation: Int, icao: String, name: String, runways: [Airport.Runway], pavement: [Airport.Pavement], linearFeatures: [Airport.LinearFeature], airportBoundary: [Airport.Node], viewPoint: Airport.ViewPoint? = nil, startupLocations: [Airport.StartupLocation], lightBeacon: Airport.LightBeacon? = nil, lightingObjects: [Airport.LightingObject], atcFrequencies: [Airport.AtcFacility]) {
        self.rowCode = rowCode
        self.elevation = elevation
        self.icao = icao
        self.name = name
        self.runways = runways
        self.pavement = pavement
        self.linearFeatures = linearFeatures
        self.airportBoundary = airportBoundary
        self.viewPoint = viewPoint
        self.startupLocations = startupLocations
        self.lightBeacon = lightBeacon
        self.lightingObjects = lightingObjects
        self.atcFrequencies = atcFrequencies
    }
    
    
    /// Row code for an airport, seaplane base or heliport. 1 - Land, 16 - Seaplane, 17 - Heliport
    public var rowCode: Int
    /// Elevation of airport in feet above mean sea level (AMSL)
    public var elevation: Int
    public var icao: String
    public var name: String
    
    //MARK: Extra Info
    ///IATA Airport code as provided in apt.dat. If you really need it, you might want to look towards a dataset like [this](https://github.com/datasets/airport-codes/blob/master/data/airport-codes.csv).
    public var iata: String?
    ///FAA Airport code as provided in apt.dat. If you really need it, you might want to look towards a dataset like [this](https://github.com/datasets/airport-codes/blob/master/data/airport-codes.csv) (local_code for american airports).
    public var faa: String?
    ///City where the airport is located as provided in apt.dat.
    public var city: String?
    ///Country the airport is located in as provided in apt.dat. If you really need it, you might want to look towards a dataset like [this](https://github.com/datasets/airport-codes/blob/master/data/airport-codes.csv).
    public var country: String?
    
    public var latitude: Float?
    public var longitude: Float?
    
    //MARK: Runways
    public var runways: [Runway]
    public struct Runway: Codable {
        
        public init(rowCode: Int, width: Float, surfaceType: Int, shoulderSurfaceType: Int, runwayEnd1: Airport.Runway.RunwayEnd, runwayEnd2: Airport.Runway.RunwayEnd) {
            self.rowCode = rowCode
            self.width = width
            self.surfaceType = surfaceType
            self.shoulderSurfaceType = shoulderSurfaceType
            self.runwayEnd1 = runwayEnd1
            self.runwayEnd2 = runwayEnd2
        }
        
        ///Row code of the runway. 100 - Land, 101 - Water, 102 - Helipad.
        public var rowCode: Int
        ///Runway width in metres
        public var width: Float
        
        public var surfaceType: Int
        public var shoulderSurfaceType: Int
        
        public var runwayEnd1: RunwayEnd
        public var runwayEnd2: RunwayEnd
        
        public struct RunwayEnd: Codable {
            
            public init(runwayNumber: String, latitude: Float, longitude: Float, displacedThresholdLength: Float, runwayMarkingType: Int) {
                self.runwayNumber = runwayNumber
                self.latitude = latitude
                self.longitude = longitude
                self.displacedThresholdLength = displacedThresholdLength
                self.runwayMarkingType = runwayMarkingType
            }
            
            public var runwayNumber: String
            public var latitude: Float
            public var longitude: Float
            
            ///Length of displaced threshold in metres (this is included in implied runway length)
            public var displacedThresholdLength: Float
            public var runwayMarkingType: Int
        }
    }
    
    //MARK: Nodes
    public var pavement: [Pavement]
    public var linearFeatures: [LinearFeature]
    public var airportBoundary: [Node]
    
    public struct Node: Codable {
        @available(*, deprecated, message: "beizerLatitude and beizerLongitude were corrected to the right spelling. This initializer perfectly works, but from now on try to use the one with bezierLatitude and bezierLongitude")
        public init(rowCode: Int, latitude: Float, longitude: Float, beizerLatitude: Float? = nil, beizerLongitude: Float? = nil, lineType: Int? = nil) {
            self.rowCode = rowCode
            self.latitude = latitude
            self.longitude = longitude
            self.bezierLatitude = beizerLatitude
            self.bezierLongitude = beizerLongitude
            self.lineType = lineType
        }
        
        @available(*, deprecated, message: "beizerLatitude and beizerLongitude were corrected to the right spelling. This still works, but it's best to change it to the correct spelling.", renamed: "bezierLatitude")
        public var beizerLatitude: Float? {
            get { bezierLatitude }
            set { bezierLatitude = newValue }
        }
        @available(*, deprecated, message: "beizerLongitude and beizerLongitude were corrected to the right spelling. This still works, but it's best to change it to the correct spelling.", renamed: "bezierLongitude")
        public var beizerLongitude: Float? {
            get { bezierLongitude }
            set { bezierLongitude = newValue }
        }
        
        public init(rowCode: Int, latitude: Float, longitude: Float, bezierLatitude: Float? = nil, bezierLongitude: Float? = nil, lineType: Int? = nil) {
            self.rowCode = rowCode
            self.latitude = latitude
            self.longitude = longitude
            self.bezierLatitude = bezierLatitude
            self.bezierLongitude = bezierLongitude
            self.lineType = lineType
        }
        
        public var rowCode: Int
        public var latitude: Float
        public var longitude: Float
        
        ///Latitude of Bezier control point, only for 112, 114, 116 row codes
        public var bezierLatitude: Float?
        ///Longitude of Bezier control point, only for 112, 114, 116 row codes
        public var bezierLongitude: Float?
        
        ///Code for painted line type on line segment starting at this node
        public var lineType: Int?
    }
    
    public struct Pavement: Codable {
        
        public init(surfaceType: Int, description: String, nodes: [Airport.Node]) {
            self.surfaceType = surfaceType
            self.description = description
            self.nodes = nodes
        }
        
        public var surfaceType: Int
        public var description: String
        public var nodes: [Node]
    }
    
    public struct LinearFeature: Codable {
        
        public init(description: String, nodes: [Airport.Node]) {
            self.description = description
            self.nodes = nodes
        }
        
        public var description: String
        public var nodes: [Node]
    }
    
    //MARK: View Point
    ///Airport's viewpoint, usually ATC tower. Maximum of ​one​ viewpoint for each airport.
    public var viewPoint: ViewPoint?
    public struct ViewPoint: Codable {
        
        public init(latitude: Float, longitude: Float, height: Int, name: String) {
            self.latitude = latitude
            self.longitude = longitude
            self.height = height
            self.name = name
        }
        
        public var latitude: Float
        public var longitude: Float
        ///Height (in feet) of viewpoint above ground level
        public var height: Int
        public var name: String
    }
    
    //MARK: Startup locations
    public var startupLocations: [StartupLocation]
    public struct StartupLocation: Codable {
        public init(latitude: Float, longitude: Float, heading: Float, name: String, locationType: String? = nil, allowedAirplaneTypes: String? = nil, icaoWidth: String? = nil) {
            self.latitude = latitude
            self.longitude = longitude
            self.heading = heading
            self.name = name
            self.locationType = locationType
            self.allowedAirplaneTypes = allowedAirplaneTypes
            self.icaoWidth = icaoWidth
        }
        
        public var latitude: Float
        public var longitude: Float
        ///Heading (true) of an aeroplane when positioned at startup location
        public var heading: Float
        ///Name of the start location. Must be unique within a single airport.
        public var name: String
        
        // Stuff only present in 1300
        
        /**
         Type of location. Can be “gate”, “hangar”, “misc” or “tie-down”
         - Note: Only available for row code 1300 gates
         */
        public var locationType: String?
        
        /**
         Airplane types that can use this location. Pipe-separated list (“|”). Can include “heavy”, ”jets”, “turboprops”, “props” and “helos” (or just “all” for all types)
         - Note: Only available for row code 1300 gates
         */
        public var allowedAirplaneTypes: String?
        
        /**
         ICAO mandated gate size. If equal to nil it is best to assume as the max possible size. See [this](https://ifatceg.com/size/) for a table of all Infinite Flight aircraft's ICAO sizes.
         - Note: Only available for row code 1300 gates with 1301 metadata row
         */
        public var icaoWidth: String?
    }
    
    //MARK: Light Beacon
    public var lightBeacon: LightBeacon?
    public struct LightBeacon: Codable {
        public init(latitude: Float, longitude: Float, beaconType: Int) {
            self.latitude = latitude
            self.longitude = longitude
            self.beaconType = beaconType
        }
        
        public var latitude: Float
        public var longitude: Float
        public var beaconType: Int
    }
    
    //MARK: Lighting Objects
    public var lightingObjects: [LightingObject]
    public struct LightingObject: Codable {
        public init(latitude: Float, longitude: Float, type: Int, orientation: Float, glideslopeAngle: Float, associatedRunway: String, description: String? = nil) {
            self.latitude = latitude
            self.longitude = longitude
            self.type = type
            self.orientation = orientation
            self.glideslopeAngle = glideslopeAngle
            self.associatedRunway = associatedRunway
            self.description = description
        }
        
        public var latitude: Float
        public var longitude: Float
        public var type: Int
        public var orientation: Float
        public var glideslopeAngle: Float
        public var associatedRunway: String
        public var description: String?
    }
    
    //MARK: ATC
    public var atcFrequencies: [AtcFacility]
    public struct AtcFacility: Codable {
        public init(rowCode: Int, frequency: Int, name: String) {
            self.rowCode = rowCode
            self.frequency = frequency
            self.name = name
        }
        
        public var rowCode: Int
        /// Frequency in kHz
        public var frequency: Int
        public var name: String
    }
}

extension Airport: Identifiable {
    public var id: String { icao }
}

//MARK: Convenience extensions
// Extensions that you might not use, but they're here if you don't want to spend all day checking the docs for the right surface code for gravel ;)

public extension Airport.AtcFacility {
    enum AtcFacilityType: Int {
        case unicom = 51
        //case clearanceDelivery = 52
        case ground = 53
        case tower = 54
        case approach = 55
        case departure = 56
    }
    
    var facilityTypeEnum: AtcFacilityType? {
        let value = rowCode % 1000
        return AtcFacilityType.init(rawValue: value)
    }
}

public extension Airport {
    enum SurfaceType: Int {
        ///Dark grey surface. For light gray see asphalt.
        case asphalt = 1
        ///Light gray surface. For dark gray see asphalt.
        case concrete = 2
        case turfGrass = 3
        case dirt = 4
        case gravel = 5
        case dryLakebed = 12
        case waterRunways = 13
        ///Snow or ice. Runways markings can't be added to runways with this surface type.
        case snow = 14
        case transparent = 15
    }
}

public extension Airport.Pavement {
    var surfaceTypeEnum: Airport.SurfaceType? {
        return Airport.SurfaceType.init(rawValue: surfaceType)
    }
}

public extension Airport.Runway {
    var surfaceTypeEnum: Airport.SurfaceType? {
        return Airport.SurfaceType.init(rawValue: surfaceType)
    }
}

public extension Airport.Runway.RunwayEnd {
    enum RunwayMarkingType: Int {
        case noMarkings = 0
        case visualMarkings = 1
        case nonPrecisionMarkings = 2
        case presicionApproachmarkers = 3
        case ukNonPrecisionMarkers = 4
        case ukPrecisionMarkers = 5
    }
    
    var RunwayMarkingTypeEnum: Airport.Runway.RunwayEnd.RunwayMarkingType? {
        return Airport.Runway.RunwayEnd.RunwayMarkingType.init(rawValue: runwayMarkingType)
    }
}

public extension Airport.Node {
    /**
     - Note: The names might be confusing, but they're pretty much from the docs. Every enum case has a description from the docs.
     */
    enum LineType: Int {
        case nothing = 0
        ///Taxiway centre lines
        case solidYellow = 1
        ///Miscellaneous boundaries
        case brokenYellow = 2
        ///Taxiway edge lines
        case doubleSolidYellow = 3
        ///Runway hold positions
        case twoBrokenTwoSolidYellow = 4
        ///Other (non-runway) hold locations
        case brokenWithSolid = 5
        ///ILS hold
        case yellowCrossHatched = 6
        ///Taxiway centerlines in runway safety zones
        case solidWithBrokenOnTheSide = 7
        ///Mark ‘lanes’ for queuing aeroplanes
        case widelySeparatedBrokenYellow = 8
        ///Mark ‘lanes’ for queuing aeroplanes
        case widelySeparatedDoubleSolidBrokenYellow = 9
        
        ///Taxiway centre lines with a black border
        case solidYellowWithBlackBorder = 51
        ///Miscellaneous boundaries with a black border
        case brokenYellowWithBlackBorder = 52
        ///Taxiway edge lines with a black border
        case doubleSolidYellowWithBlackBorder = 53
        ///Runway hold positions with a black border
        case twoBrokenTwoSolidYellowWithBlackBorder = 54
        ///Other (non-runway) hold locations with a black border
        case brokenWithSolidWithBlackBorder = 55
        ///ILS hold with a black border
        case yellowCrossHatchedWithBlackBorder = 56
        ///Taxiway centerlines in runway safety zones with a black border
        case solidWithBrokenOnTheSideWithBlackBorder = 57
        ///Mark ‘lanes’ for queuing aeroplanes with a black border
        case widelySeparatedBrokenYellowWithBlackBorder = 58
        ///Mark ‘lanes’ for queuing aeroplanes with a black border
        case widelySeparatedDoubleSolidBrokenYellowWithBlackBorder = 59
        
        ///Roadway markings
        case solidWhite = 20
        ///Roadway markings
        case checkerboardWhite = 21
        ///Roadway markings
        case brokenWhite = 22
    }
    var lineTypeEnum: Airport.Node.LineType? {
        // 100 is just a placeholder to send nil
        return Airport.Node.LineType.init(rawValue: lineType ?? 100)
    }
    
    enum NodeType: Int {
        ///Node
        case normal = 111
        ///Node with Bezier control point
        case bezier = 112
        /**
         Node with implicit close of loop
         - Warning: This, along with `.bezierCloseLoop` (row code 113) doesn't always mean that the object finished.
         */
        case normalCloseLoop = 113
        /**
         Node with Bezier control point, with implicit close of loop
         - Warning: This, along with `.normalCloseLoop` (row code 113) doesn't always mean that the object finished.
         */
        case bezierCloseLoop = 114
        ///Node terminating a string (no close loop)
        case normalLineTermination = 115
        ///Node with Bezier control point, terminating a string (no close loop)
        case bezierLineTermination = 116
        
        ///In theory this shouldn't ever appear, but it's here just in case.
        case unknownRowCode = 404
    }
    
    ///enum type of the node based on it's row code
    var nodeType: NodeType {
        return NodeType.init(rawValue: rowCode) ?? .unknownRowCode
    }
}

public extension Airport.LightBeacon {
    enum BeaconType: Int {
        ///No beacon. Suppresses automatic creation of beacon by X-Plane.
        case none = 0
        ///White-green flashing (Civilian airport)
        case whiteGreen = 1
        ///White-yellow flashing (Seaplane base)
        case whiteYellow = 2
        ///Green-yellow-white flashing (Heliport)
        case greenWhiteYellow = 3
        ///White-white-green flashing (Military airport)
        case whiteWhiteGreen = 4
    }
    
    var beaconTypeEnum: BeaconType? {
        return BeaconType.init(rawValue: beaconType)
    }
}

public extension Airport.LightingObject {
    enum LightingObjectType: Int {
        ///VASI. Location is centre point between the two VASI units
        case vasi = 1
        ///Left-handed papi: red indication appears first on ​right​ 2 lights
        case papi4L = 2
        ///Right-handed papi: red indication appears first on ​left​ 2 lights
        case papi4R = 3
        ///Papi with 20 degree glidepath. Deprecated. Use normal PAPI with an appropriate angle.
        case spaceShuttlePapi = 4
        ///Tri-colour VASI
        case triColorPapi = 5
        ///Runway guard (“wig-wag”) lights. Pulsating double amber lights alongside runway entrances
        case runwayGuardLights = 6
    }
    var lightingObjectTypeEnum: LightingObjectType? {
        return LightingObjectType.init(rawValue: type)
    }
}

public extension Airport.StartupLocation {
    ///ICAO type of the startup locations. See descriptions for aircraft in that class.  Please note this information might become outdated, for up to date information visit [this](https://ifatceg.com/size/)
    enum StartupLocationType: String {
        ///Aircraft: C172, SR22, F-14, F-16, F-18, F-22, Spitfire, TBM, XCub
        case a = "A"
        ///Aircraft: A-10, C208, Citation, CRJ
        case b = "B"
        ///Aircraft: A320, B717, B737, ERJ, Q400
        case c = "C"
        ///Aircraft: B757, B767, C-130, C-17, DC10, MD11
        case d = "D"
        ///Aircraft: A330, A340, A350, B747-200, B747-400, B777, B787
        case e = "E"
        ///Aircraft: A380, B747-8
        case f = "F"
        ///Appears in old airports for row code 15 startup locations or row code 1300 locations without a row code 1302 metadata row.
        case unknown = "unknown"
    }
    
    var enumSize: StartupLocationType {
        return StartupLocationType(rawValue: self.icaoWidth?.uppercased() ?? "unknown") ?? .unknown
    }
}

//MARK: Extensions with functions


extension Airport {
    
    //MARK: Location Calculation
    /// Calculates the location based on the approximate center of the airport's boundary and sets `latitude` and `longitude` to the calculated values. Won't generate if boundary is empty.
    mutating func calculateLocationBasedOnBoundary() {
        guard !self.airportBoundary.isEmpty else {return}
        
        var minLat: Float = 360
        var maxLat: Float = -360
        var minLon: Float = 360
        var maxLon: Float = -360
        
        for node in airportBoundary {
            if node.latitude < minLat {
                minLat = node.latitude
            } else if node.latitude > maxLat {
                maxLat = node.latitude
            }
            
            if node.longitude < minLon {
                minLon = node.longitude
            } else if node.longitude > maxLon {
                maxLon = node.longitude
            }
        }
        
        self.latitude = (minLat + maxLat) / 2
        self.longitude = (minLon + maxLon) / 2
    }
    
    /**
     Calculates the location based on the center of the bounding box based on all of airport's runways and sets `latitude` and `longitude` to the calculated values. Won't generate if the `runways` array is empty.
     - Note: This is the method that is used on Infinite Flight's in-game map
     */
    mutating func calculateLocationBasedOnRunways() {
        
        var minLat: Float = 360
        var maxLat: Float = -360
        var minLon: Float = 360
        var maxLon: Float = -360
        
        let runwayEnds = runways.map { $0.runwayEnd1 } + runways.map { $0.runwayEnd2 }
        
        for runwayEnd in runwayEnds {
            if runwayEnd.latitude < minLat {
                minLat = runwayEnd.latitude
            } else if runwayEnd.latitude > maxLat {
                maxLat = runwayEnd.latitude
            }
            
            if runwayEnd.longitude < minLon {
                minLon = runwayEnd.longitude
            } else if runwayEnd.longitude > maxLon {
                maxLon = runwayEnd.longitude
            }
        }
        
        self.latitude = (minLat + maxLat) / 2
        self.longitude = (minLon + maxLon) / 2
    }
}
